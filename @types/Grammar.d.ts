export default grammar;
declare const grammar: "\n// JavaScript Grammar\n// ==================\n//\n// Based on grammar from ECMA-262, 5.1 Edition [1]. Generated parser builds a\n// syntax tree compatible with the ESTree spec [2].\n//\n// Limitations:\n//\n//   * Non-BMP characters are completely ignored to avoid surrogate pair\n//     handling.\n//\n//   * One can create identifiers containing illegal characters using Unicode\n//     escape sequences. For example, \"abcd efgh\" is not a valid\n//     identifier, but it is accepted by the parser.\n//\n//   * Strict mode is not recognized. This means that within strict mode code,\n//     \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\",\n//     \"public\", \"static\" and \"yield\" can be used as names. Many other\n//     restrictions and exceptions from Annex C are also not applied.\n//\n// All the limitations could be resolved, but the costs would likely outweigh\n// the benefits.\n//\n// Many thanks to inimino [3] for his grammar [4] which helped me to solve some\n// problems (such as automatic semicolon insertion) and also served to double\n// check that I converted the original grammar correctly.\n//\n// [1] http://www.ecma-international.org/publications/standards/Ecma-262.htm\n// [2] https://github.com/estree/estree\n// [3] http://inimino.org/~inimino/blog/\n// [4] http://boshi.inimino.org/3box/asof/1270029991384/PEG/ECMAScript_unified.peg\n\n{\n  var TYPES_TO_PROPERTY_NAMES = {\n    CallExpression:   \"callee\",\n    MemberExpression: \"object\",\n  };\n\n  function filledArray(count, value) {\n    return Array.apply(null, new Array(count))\n      .map(function() { return value; });\n  }\n\n  function extractOptional(optional, index) {\n    return optional ? optional[index] : null;\n  }\n\n  function extractList(list, index) {\n    return list.map(function(element) { return element[index]; });\n  }\n\n  function buildList(head, tail, index) {\n    return [head].concat(extractList(tail, index));\n  }\n\n  function buildBinaryExpression(head, tail) {\n    return tail.reduce(function(result, element) {\n      return {\n        type: \"BinaryExpression\",\n        operator: element[1],\n        left: result,\n        right: element[3]\n      };\n    }, head);\n  }\n\n  function buildLogicalExpression(head, tail) {\n    return tail.reduce(function(result, element) {\n      return {\n        type: \"LogicalExpression\",\n        operator: element[1],\n        left: result,\n        right: element[3]\n      };\n    }, head);\n  }\n\n  function optionalList(value) {\n    return value !== null ? value : [];\n  }\n}\n\nStart\n  = __ program:Program __ { return program; }\n\n// ----- A.1 Lexical Grammar -----\n\nSourceCharacter\n  = .\n\nWhiteSpace \"whitespace\"\n  = \"\t\"\n  / \"\v\"\n  / \"\f\"\n  / \" \"\n  / \" \"\n  / \"﻿\"\n  / Zs\n\nLineTerminator\n  = [\n\r\u2028\u2029]\n\nLineTerminatorSequence \"end of line\"\n  = \"\n\"\n  / \"\r\n\"\n  / \"\r\"\n  / \"\u2028\"\n  / \"\u2029\"\n\nComment \"comment\"\n  = MultiLineComment\n  / SingleLineComment\n\nMultiLineComment\n  = \"/*\" (!\"*/\" SourceCharacter)* \"*/\"\n\nMultiLineCommentNoLineTerminator\n  = \"/*\" (!(\"*/\" / LineTerminator) SourceCharacter)* \"*/\"\n\nSingleLineComment\n  = \"//\" (!LineTerminator SourceCharacter)*\n\nIdentifier\n  = !ReservedWord name:IdentifierName { return name; }\n\nIdentifierName \"identifier\"\n  = head:IdentifierStart tail:IdentifierPart* {\n      return {\n        type: \"Identifier\",\n        name: head + tail.join(\"\")\n      };\n    }\n\nIdentifierStart\n  = UnicodeLetter\n  / \"$\"\n  / \"_\"\n  / \"\\\" sequence:UnicodeEscapeSequence { return sequence; }\n\nIdentifierPart\n  = IdentifierStart\n  / UnicodeCombiningMark\n  / UnicodeDigit\n  / UnicodeConnectorPunctuation\n  / \"‌\"\n  / \"‍\"\n\nUnicodeLetter\n  = Lu\n  / Ll\n  / Lt\n  / Lm\n  / Lo\n  / Nl\n\nUnicodeCombiningMark\n  = Mn\n  / Mc\n\nUnicodeDigit\n  = Nd\n\nUnicodeConnectorPunctuation\n  = Pc\n\nReservedWord\n  = Keyword\n  / FutureReservedWord\n  / NullLiteral\n  / BooleanLiteral\n\nKeyword\n  = BreakToken\n  / CaseToken\n  / CatchToken\n  / ContinueToken\n  / DebuggerToken\n  / DefaultToken\n  / DeleteToken\n  / DoToken\n  / ElseToken\n  / FinallyToken\n  / ForToken\n  / FunctionToken\n  / IfToken\n  / InstanceofToken\n  / InToken\n  / NewToken\n  / ReturnToken\n  / SwitchToken\n  / ThisToken\n  / ThrowToken\n  / TryToken\n  / TypeofToken\n  / VarToken\n  / VoidToken\n  / WhileToken\n  / WithToken\n\nFutureReservedWord\n  = ClassToken\n  / ConstToken\n  / EnumToken\n  / ExportToken\n  / ExtendsToken\n  / ImportToken\n  / SuperToken\n\nLiteral\n  = NullLiteral\n  / BooleanLiteral\n  / NumericLiteral\n  / StringLiteral\n  / RegularExpressionLiteral\n\nNullLiteral\n  = NullToken { return { type: \"Literal\", value: null }; }\n\nBooleanLiteral\n  = TrueToken  { return { type: \"Literal\", value: true  }; }\n  / FalseToken { return { type: \"Literal\", value: false }; }\n\n// The \"!(IdentifierStart / DecimalDigit)\" predicate is not part of the official\n// grammar, it comes from text in section 7.8.3.\nNumericLiteral \"number\"\n  = literal:HexIntegerLiteral !(IdentifierStart / DecimalDigit) {\n      return literal;\n    }\n  / literal:DecimalLiteral !(IdentifierStart / DecimalDigit) {\n      return literal;\n    }\n\nDecimalLiteral\n  = DecimalIntegerLiteral \".\" DecimalDigit* ExponentPart? {\n      return { type: \"Literal\", value: parseFloat(text()) };\n    }\n  / \".\" DecimalDigit+ ExponentPart? {\n      return { type: \"Literal\", value: parseFloat(text()) };\n    }\n  / DecimalIntegerLiteral ExponentPart? {\n      return { type: \"Literal\", value: parseFloat(text()) };\n    }\n\nDecimalIntegerLiteral\n  = \"0\"\n  / NonZeroDigit DecimalDigit*\n\nDecimalDigit\n  = [0-9]\n\nNonZeroDigit\n  = [1-9]\n\nExponentPart\n  = ExponentIndicator SignedInteger\n\nExponentIndicator\n  = \"e\"i\n\nSignedInteger\n  = [+-]? DecimalDigit+\n\nHexIntegerLiteral\n  = \"0x\"i digits:$HexDigit+ {\n      return { type: \"Literal\", value: parseInt(digits, 16) };\n     }\n\nHexDigit\n  = [0-9a-f]i\n\nStringLiteral \"string\"\n  = '\"' chars:DoubleStringCharacter* '\"' {\n      return { type: \"Literal\", value: chars.join(\"\") };\n    }\n  / \"'\" chars:SingleStringCharacter* \"'\" {\n      return { type: \"Literal\", value: chars.join(\"\") };\n    }\n\nDoubleStringCharacter\n  = !('\"' / \"\\\" / LineTerminator) SourceCharacter { return text(); }\n  / \"\\\" sequence:EscapeSequence { return sequence; }\n  / LineContinuation\n\nSingleStringCharacter\n  = !(\"'\" / \"\\\" / LineTerminator) SourceCharacter { return text(); }\n  / \"\\\" sequence:EscapeSequence { return sequence; }\n  / LineContinuation\n\nLineContinuation\n  = \"\\\" LineTerminatorSequence { return \"\"; }\n\nEscapeSequence\n  = CharacterEscapeSequence\n  / \"0\" !DecimalDigit { return \"\0\"; }\n  / HexEscapeSequence\n  / UnicodeEscapeSequence\n\nCharacterEscapeSequence\n  = SingleEscapeCharacter\n  / NonEscapeCharacter\n\nSingleEscapeCharacter\n  = \"'\"\n  / '\"'\n  / \"\\\"\n  / \"b\"  { return \"\b\"; }\n  / \"f\"  { return \"\f\"; }\n  / \"n\"  { return \"\n\"; }\n  / \"r\"  { return \"\r\"; }\n  / \"t\"  { return \"\t\"; }\n  / \"v\"  { return \"\v\"; }\n\nNonEscapeCharacter\n  = !(EscapeCharacter / LineTerminator) SourceCharacter { return text(); }\n\nEscapeCharacter\n  = SingleEscapeCharacter\n  / DecimalDigit\n  / \"x\"\n  / \"u\"\n\nHexEscapeSequence\n  = \"x\" digits:$(HexDigit HexDigit) {\n      return String.fromCharCode(parseInt(digits, 16));\n    }\n\nUnicodeEscapeSequence\n  = \"u\" digits:$(HexDigit HexDigit HexDigit HexDigit) {\n      return String.fromCharCode(parseInt(digits, 16));\n    }\n\nRegularExpressionLiteral \"regular expression\"\n  = \"/\" pattern:$RegularExpressionBody \"/\" flags:$RegularExpressionFlags {\n      var value;\n\n      try {\n        value = new RegExp(pattern, flags);\n      } catch (e) {\n        error(e.message);\n      }\n\n      return { type: \"Literal\", value: value };\n    }\n\nRegularExpressionBody\n  = RegularExpressionFirstChar RegularExpressionChar*\n\nRegularExpressionFirstChar\n  = ![*\\/[] RegularExpressionNonTerminator\n  / RegularExpressionBackslashSequence\n  / RegularExpressionClass\n\nRegularExpressionChar\n  = ![\\/[] RegularExpressionNonTerminator\n  / RegularExpressionBackslashSequence\n  / RegularExpressionClass\n\nRegularExpressionBackslashSequence\n  = \"\\\" RegularExpressionNonTerminator\n\nRegularExpressionNonTerminator\n  = !LineTerminator SourceCharacter\n\nRegularExpressionClass\n  = \"[\" RegularExpressionClassChar* \"]\"\n\nRegularExpressionClassChar\n  = ![]\\] RegularExpressionNonTerminator\n  / RegularExpressionBackslashSequence\n\nRegularExpressionFlags\n  = IdentifierPart*\n\n// Unicode Character Categories\n//\n// Extracted from the following Unicode Character Database file:\n//\n//   http://www.unicode.org/Public/11.0.0/ucd/extracted/DerivedGeneralCategory.txt\n//\n// Unix magic used:\n//\n//   grep \"; $CATEGORY\" DerivedGeneralCategory.txt |   # Filter characters\n//     cut -f1 -d \" \" |                                # Extract code points\n//     grep -v '[0-9a-fA-F]{5}' |                    # Exclude non-BMP characters\n//     sed -e 's/../-/' |                            # Adjust formatting\n//     tr -d '\n'                                      # Join lines\n//\n// ECMA-262 allows using Unicode 3.0 or later, version 8.0.0 was the latest one\n// at the time of writing.\n//\n// Non-BMP characters are completely ignored to avoid surrogate pair handling\n// (detecting surrogate pairs isn't possible with a simple character class and\n// other methods would degrade performance). I don't consider it a big deal as\n// even parsers in JavaScript engines of common browsers seem to ignore them.\n\n// Letter, Lowercase\nLl = [a-zµß-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĳĵķ-ĸĺļľŀłńņň-ŉŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżž-ƀƃƅƈƌ-ƍƒƕƙ-ƛƞơƣƥƨƪ-ƫƭưƴƶƹ-ƺƽ-ƿǆǉǌǎǐǒǔǖǘǚǜ-ǝǟǡǣǥǧǩǫǭǯ-ǰǳǵǹǻǽǿȁȃȅȇȉȋȍȏȑȓȕȗșțȝȟȡȣȥȧȩȫȭȯȱȳ-ȹȼȿ-ɀɂɇɉɋɍɏ-ʓʕ-ʯͱͳͷͻ-ͽΐά-ώϐ-ϑϕ-ϗϙϛϝϟϡϣϥϧϩϫϭϯ-ϳϵϸϻ-ϼа-џѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁҋҍҏґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӆӈӊӌӎ-ӏӑӓӕӗәӛӝӟӡӣӥӧөӫӭӯӱӳӵӷӹӻӽӿԁԃԅԇԉԋԍԏԑԓԕԗԙԛԝԟԡԣԥԧԩԫԭԯՠ-ֈა-ჺჽ-ჿᏸ-ᏽᲀ-ᲈᴀ-ᴫᵫ-ᵷᵹ-ᶚḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿẁẃẅẇẉẋẍẏẑẓẕ-ẝẟạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗộớờởỡợụủứừửữựỳỵỷỹỻỽỿ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶ-ᾷιῂ-ῄῆ-ῇῐ-ΐῖ-ῗῠ-ῧῲ-ῴῶ-ῷℊℎ-ℏℓℯℴℹℼ-ℽⅆ-ⅉⅎↄⰰ-ⱞⱡⱥ-ⱦⱨⱪⱬⱱⱳ-ⱴⱶ-ⱻⲁⲃⲅⲇⲉⲋⲍⲏⲑⲓⲕⲗⲙⲛⲝⲟⲡⲣⲥⲧⲩⲫⲭⲯⲱⲳⲵⲷⲹⲻⲽⲿⳁⳃⳅⳇⳉⳋⳍⳏⳑⳓⳕⳗⳙⳛⳝⳟⳡⳣ-ⳤⳬⳮⳳⴀ-ⴥⴧⴭꙁꙃꙅꙇꙉꙋꙍꙏꙑꙓꙕꙗꙙꙛꙝꙟꙡꙣꙥꙧꙩꙫꙭꚁꚃꚅꚇꚉꚋꚍꚏꚑꚓꚕꚗꚙꚛꜣꜥꜧꜩꜫꜭꜯ-ꜱꜳꜵꜷꜹꜻꜽꜿꝁꝃꝅꝇꝉꝋꝍꝏꝑꝓꝕꝗꝙꝛꝝꝟꝡꝣꝥꝧꝩꝫꝭꝯꝱ-ꝸꝺꝼꝿꞁꞃꞅꞇꞌꞎꞑꞓ-ꞕꞗꞙꞛꞝꞟꞡꞣꞥꞧꞩꞯꞵꞷꞹꟺꬰ-ꭚꭠ-ꭥꭰ-ꮿﬀ-ﬆﬓ-ﬗａ-ｚ]\n\n// Letter, Modifier\nLm = [ʰ-ˁˆ-ˑˠ-ˤˬˮʹͺՙـۥ-ۦߴ-ߵߺࠚࠤࠨॱๆໆჼៗᡃᪧᱸ-ᱽᴬ-ᵪᵸᶛ-ᶿⁱⁿₐ-ₜⱼ-ⱽⵯⸯ々〱-〵〻ゝ-ゞー-ヾꀕꓸ-ꓽꘌꙿꚜ-ꚝꜗ-ꜟꝰꞈꟸ-ꟹꧏꧦꩰꫝꫳ-ꫴꭜ-ꭟｰﾞ-ﾟ]\n\n// Letter, Other\nLo = [ªºƻǀ-ǃʔא-תׯ-ײؠ-ؿف-يٮ-ٯٱ-ۓەۮ-ۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪࠀ-ࠕࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॲ-ঀঅ-ঌএ-ঐও-নপ-রলশ-হঽৎড়-ঢ়য়-ৡৰ-ৱৼਅ-ਊਏ-ਐਓ-ਨਪ-ਰਲ-ਲ਼ਵ-ਸ਼ਸ-ਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલ-ળવ-હઽૐૠ-ૡૹଅ-ଌଏ-ଐଓ-ନପ-ରଲ-ଳଵ-ହଽଡ଼-ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கங-சஜஞ-டண-தந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠ-ౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠ-ೡೱ-ೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะา-ำเ-ๅກ-ຂຄງ-ຈຊຍດ-ທນ-ຟມ-ຣລວສ-ຫອ-ະາ-ຳຽເ-ໄໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥ-ၦၮ-ၰၵ-ႁႎᄀ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛱ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៜᠠ-ᡂᡄ-ᡸᢀ-ᢄᢇ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮ-ᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱷᳩ-ᳬᳮ-ᳱᳵ-ᳶℵ-ℸⴰ-ⵧⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ〆〼ぁ-ゖゟァ-ヺヿㄅ-ㄯㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿯ꀀ-ꀔꀖ-ꒌꓐ-ꓷꔀ-ꘋꘐ-ꘟꘪ-ꘫꙮꚠ-ꛥꞏꟷꟻ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽ-ꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧠ-ꧤꧧ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩯꩱ-ꩶꩺꩾ-ꪯꪱꪵ-ꪶꪹ-ꪽꫀꫂꫛ-ꫜꫠ-ꫪꫲꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎יִײַ-ﬨשׁ-זּטּ-לּמּנּ-סּףּ-פּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼｦ-ｯｱ-ﾝﾠ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ]\n\n// Letter, Titlecase\nLt = [ǅǈǋǲᾈ-ᾏᾘ-ᾟᾨ-ᾯᾼῌῼ]\n\n// Letter, Uppercase\nLu = [A-ZÀ-ÖØ-ÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬĮİĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŸ-ŹŻŽƁ-ƂƄƆ-ƇƉ-ƋƎ-ƑƓ-ƔƖ-ƘƜ-ƝƟ-ƠƢƤƦ-ƧƩƬƮ-ƯƱ-ƳƵƷ-ƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǶ-ǸǺǼǾȀȂȄȆȈȊȌȎȐȒȔȖȘȚȜȞȠȢȤȦȨȪȬȮȰȲȺ-ȻȽ-ȾɁɃ-ɆɈɊɌɎͰͲͶͿΆΈ-ΊΌΎ-ΏΑ-ΡΣ-ΫϏϒ-ϔϘϚϜϞϠϢϤϦϨϪϬϮϴϷϹ-ϺϽ-ЯѠѢѤѦѨѪѬѮѰѲѴѶѸѺѼѾҀҊҌҎҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӀ-ӁӃӅӇӉӋӍӐӒӔӖӘӚӜӞӠӢӤӦӨӪӬӮӰӲӴӶӸӺӼӾԀԂԄԆԈԊԌԎԐԒԔԖԘԚԜԞԠԢԤԦԨԪԬԮԱ-ՖႠ-ჅჇჍᎠ-ᏵᲐ-ᲺᲽ-ᲿḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾẀẂẄẆẈẊẌẎẐẒẔẞẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸỺỼỾἈ-ἏἘ-ἝἨ-ἯἸ-ἿὈ-ὍὙὛὝὟὨ-ὯᾸ-ΆῈ-ΉῘ-ΊῨ-ῬῸ-Ώℂℇℋ-ℍℐ-ℒℕℙ-ℝℤΩℨK-ℭℰ-ℳℾ-ℿⅅↃⰀ-ⰮⱠⱢ-ⱤⱧⱩⱫⱭ-ⱰⱲⱵⱾ-ⲀⲂⲄⲆⲈⲊⲌⲎⲐⲒⲔⲖⲘⲚⲜⲞⲠⲢⲤⲦⲨⲪⲬⲮⲰⲲⲴⲶⲸⲺⲼⲾⳀⳂⳄⳆⳈⳊⳌⳎⳐⳒⳔⳖⳘⳚⳜⳞⳠⳢⳫⳭⳲꙀꙂꙄꙆꙈꙊꙌꙎꙐꙒꙔꙖꙘꙚꙜꙞꙠꙢꙤꙦꙨꙪꙬꚀꚂꚄꚆꚈꚊꚌꚎꚐꚒꚔꚖꚘꚚꜢꜤꜦꜨꜪꜬꜮꜲꜴꜶꜸꜺꜼꜾꝀꝂꝄꝆꝈꝊꝌꝎꝐꝒꝔꝖꝘꝚꝜꝞꝠꝢꝤꝦꝨꝪꝬꝮꝹꝻꝽ-ꝾꞀꞂꞄꞆꞋꞍꞐꞒꞖꞘꞚꞜꞞꞠꞢꞤꞦꞨꞪ-ꞮꞰ-ꞴꞶꞸＡ-Ｚ]\n\n// Mark, Spacing Combining\nMc = [ःऻा-ीॉ-ौॎ-ॏং-ঃা-ীে-ৈো-ৌৗਃਾ-ੀઃા-ીૉો-ૌଂ-ଃାୀେ-ୈୋ-ୌୗா-ிு-ூெ-ைொ-ௌௗఁ-ఃు-ౄಂ-ಃಾೀ-ೄೇ-ೈೊ-ೋೕ-ೖം-ഃാ-ീെ-ൈൊ-ൌൗං-ඃා-ෑෘ-ෟෲ-ෳ༾-༿ཿါ-ာေးျ-ြၖ-ၗၢ-ၤၧ-ၭႃ-ႄႇ-ႌႏႚ-ႜាើ-ៅះ-ៈᤣ-ᤦᤩ-ᤫᤰ-ᤱᤳ-ᤸᨙ-ᨚᩕᩗᩡᩣ-ᩤᩭ-ᩲᬄᬵᬻᬽ-ᭁᭃ-᭄ᮂᮡᮦ-ᮧ᮪ᯧᯪ-ᯬᯮ᯲-᯳ᰤ-ᰫᰴ-ᰵ᳡ᳲ-ᳳ᳷〮-〯ꠣ-ꠤꠧꢀ-ꢁꢴ-ꣃꥒ-꥓ꦃꦴ-ꦵꦺ-ꦻꦽ-꧀ꨯ-ꨰꨳ-ꨴꩍꩻꩽꫫꫮ-ꫯꫵꯣ-ꯤꯦ-ꯧꯩ-ꯪ꯬]\n\n// Mark, Nonspacing\nMn = [̀-ͯ҃-֑҇-ֽֿׁ-ׂׄ-ׇׅؐ-ًؚ-ٰٟۖ-ۜ۟-ۤۧ-۪ۨ-ܑۭܰ-݊ަ-ް߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ंऺ़ु-ै्॑-ॗॢ-ॣঁ়ু-ৄ্ৢ-ৣ৾ਁ-ਂ਼ੁ-ੂੇ-ੈੋ-੍ੑੰ-ੱੵઁ-ં઼ુ-ૅે-ૈ્ૢ-ૣૺ-૿ଁ଼ିୁ-ୄ୍ୖୢ-ୣஂீ்ఀఄా-ీె-ైొ-్ౕ-ౖౢ-ౣಁ಼ಿೆೌ-್ೢ-ೣഀ-ഁ഻-഼ു-ൄ്ൢ-ൣ්ි-ුූัิ-ฺ็-๎ັິ-ູົ-ຼ່-ໍ༘-ཱ༹༙༵༷-ཾྀ-྄྆-྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္-်ွ-ှၘ-ၙၞ-ၠၱ-ၴႂႅ-ႆႍႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒ-ᝓᝲ-ᝳ឴-឵ិ-ួំ៉-៓៝᠋-᠍ᢅ-ᢆᢩᤠ-ᤢᤧ-ᤨᤲ᤹-᤻ᨗ-ᨘᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽ᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀ-ᮁᮢ-ᮥᮨ-ᮩ᮫-ᮭ᯦ᯨ-ᯩᯭᯯ-ᯱᰬ-ᰳᰶ-᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸-᳹᷀-᷹᷻-᷿⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙〭-゚꙯ꙴ-꙽ꚞ-ꚟ꛰-꛱ꠂ꠆ꠋꠥ-ꠦ꣄-ꣅ꣠-꣱ꣿꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꧥꨩ-ꨮꨱ-ꨲꨵ-ꨶꩃꩌꩼꪰꪲ-ꪴꪷ-ꪸꪾ-꪿꫁ꫬ-ꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯]\n\n// Number, Decimal Digit\nNd = [0-9٠-٩۰-۹߀-߉०-९০-৯੦-੯૦-૯୦-୯௦-௯౦-౯೦-೯൦-൯෦-෯๐-๙໐-໙༠-༩၀-၉႐-႙០-៩᠐-᠙᥆-᥏᧐-᧙᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙꘠-꘩꣐-꣙꤀-꤉꧐-꧙꧰-꧹꩐-꩙꯰-꯹０-９]\n\n// Number, Letter\nNl = [ᛮ-ᛰⅠ-ↂↅ-ↈ〇〡-〩〸-〺ꛦ-ꛯ]\n\n// Punctuation, Connector\nPc = [_‿-⁀⁔︳-︴﹍-﹏＿]\n\n// Separator, Space\nZs = [    -   　]\n\n// Tokens\n\nBreakToken      = \"break\"      !IdentifierPart\nCaseToken       = \"case\"       !IdentifierPart\nCatchToken      = \"catch\"      !IdentifierPart\nClassToken      = \"class\"      !IdentifierPart\nConstToken      = \"const\"      !IdentifierPart\nContinueToken   = \"continue\"   !IdentifierPart\nDebuggerToken   = \"debugger\"   !IdentifierPart\nDefaultToken    = \"default\"    !IdentifierPart\nDeleteToken     = \"delete\"     !IdentifierPart\nDoToken         = \"do\"         !IdentifierPart\nElseToken       = \"else\"       !IdentifierPart\nEnumToken       = \"enum\"       !IdentifierPart\nExportToken     = \"export\"     !IdentifierPart\nExtendsToken    = \"extends\"    !IdentifierPart\nFalseToken      = \"false\"      !IdentifierPart\nFinallyToken    = \"finally\"    !IdentifierPart\nForToken        = \"for\"        !IdentifierPart\nFunctionToken   = \"function\"   !IdentifierPart\nGetToken        = \"get\"        !IdentifierPart\nIfToken         = \"if\"         !IdentifierPart\nImportToken     = \"import\"     !IdentifierPart\nInstanceofToken = \"instanceof\" !IdentifierPart\nInToken         = \"in\"         !IdentifierPart\nNewToken        = \"new\"        !IdentifierPart\nNullToken       = \"null\"       !IdentifierPart\nReturnToken     = \"return\"     !IdentifierPart\nSetToken        = \"set\"        !IdentifierPart\nSuperToken      = \"super\"      !IdentifierPart\nSwitchToken     = \"switch\"     !IdentifierPart\nThisToken       = \"this\"       !IdentifierPart\nThrowToken      = \"throw\"      !IdentifierPart\nTrueToken       = \"true\"       !IdentifierPart\nTryToken        = \"try\"        !IdentifierPart\nTypeofToken     = \"typeof\"     !IdentifierPart\nVarToken        = \"var\"        !IdentifierPart\nVoidToken       = \"void\"       !IdentifierPart\nWhileToken      = \"while\"      !IdentifierPart\nWithToken       = \"with\"       !IdentifierPart\n\n// Skipped\n\n__\n  = (WhiteSpace / LineTerminatorSequence / Comment)*\n\n_\n  = (WhiteSpace / MultiLineCommentNoLineTerminator)*\n\n// Automatic Semicolon Insertion\n\nEOS\n  = __ \";\"\n  / _ SingleLineComment? LineTerminatorSequence\n  / _ &\"}\"\n  / __ EOF\n\nEOF\n  = !.\n\n// ----- A.2 Number Conversions -----\n\n// Irrelevant.\n\n// ----- A.3 Expressions -----\n\nPrimaryExpression\n  = ThisToken { return { type: \"ThisExpression\" }; }\n  / Identifier\n  / Literal\n  / ArrayLiteral\n  / ObjectLiteral\n  / \"(\" __ expression:Expression __ \")\" { return expression; }\n\nArrayLiteral\n  = \"[\" __ elision:(Elision __)? \"]\" {\n      return {\n        type: \"ArrayExpression\",\n        elements: optionalList(extractOptional(elision, 0))\n      };\n    }\n  / \"[\" __ elements:ElementList __ \"]\" {\n      return {\n        type: \"ArrayExpression\",\n        elements: elements\n      };\n    }\n  / \"[\" __ elements:ElementList __ \",\" __ elision:(Elision __)? \"]\" {\n      return {\n        type: \"ArrayExpression\",\n        elements: elements.concat(optionalList(extractOptional(elision, 0)))\n      };\n    }\n\nElementList\n  = head:(\n      elision:(Elision __)? element:AssignmentExpression {\n        return optionalList(extractOptional(elision, 0)).concat(element);\n      }\n    )\n    tail:(\n      __ \",\" __ elision:(Elision __)? element:AssignmentExpression {\n        return optionalList(extractOptional(elision, 0)).concat(element);\n      }\n    )*\n    { return Array.prototype.concat.apply(head, tail); }\n\nElision\n  = \",\" commas:(__ \",\")* { return filledArray(commas.length + 1, null); }\n\nObjectLiteral\n  = \"{\" __ \"}\" { return { type: \"ObjectExpression\", properties: [] }; }\n  / \"{\" __ properties:PropertyNameAndValueList __ \"}\" {\n       return { type: \"ObjectExpression\", properties: properties };\n     }\n  / \"{\" __ properties:PropertyNameAndValueList __ \",\" __ \"}\" {\n       return { type: \"ObjectExpression\", properties: properties };\n     }\nPropertyNameAndValueList\n  = head:PropertyAssignment tail:(__ \",\" __ PropertyAssignment)* {\n      return buildList(head, tail, 3);\n    }\n\nPropertyAssignment\n  = key:PropertyName __ \":\" __ value:AssignmentExpression {\n      return { type: \"Property\", key: key, value: value, kind: \"init\" };\n    }\n  / GetToken __ key:PropertyName __\n    \"(\" __ \")\" __\n    \"{\" __ body:FunctionBody __ \"}\"\n    {\n      return {\n        type: \"Property\",\n        key: key,\n        value: {\n          type: \"FunctionExpression\",\n          id: null,\n          params: [],\n          body: body\n        },\n        kind: \"get\"\n      };\n    }\n  / SetToken __ key:PropertyName __\n    \"(\" __ params:PropertySetParameterList __ \")\" __\n    \"{\" __ body:FunctionBody __ \"}\"\n    {\n      return {\n        type: \"Property\",\n        key: key,\n        value: {\n          type: \"FunctionExpression\",\n          id: null,\n          params: params,\n          body: body\n        },\n        kind: \"set\"\n      };\n    }\n\nPropertyName\n  = IdentifierName\n  / StringLiteral\n  / NumericLiteral\n\nPropertySetParameterList\n  = id:Identifier { return [id]; }\n\nMemberExpression\n  = head:(\n        PrimaryExpression\n      / FunctionExpression\n      / NewToken __ callee:MemberExpression __ args:Arguments {\n          return { type: \"NewExpression\", callee: callee, arguments: args };\n        }\n    )\n    tail:(\n        __ \"[\" __ property:Expression __ \"]\" {\n          return { property: property, computed: true };\n        }\n      / __ \".\" __ property:IdentifierName {\n          return { property: property, computed: false };\n        }\n    )*\n    {\n      return tail.reduce(function(result, element) {\n        return {\n          type: \"MemberExpression\",\n          object: result,\n          property: element.property,\n          computed: element.computed\n        };\n      }, head);\n    }\n\nNewExpression\n  = MemberExpression\n  / NewToken __ callee:NewExpression {\n      return { type: \"NewExpression\", callee: callee, arguments: [] };\n    }\n\nCallExpression\n  = head:(\n      callee:MemberExpression __ args:Arguments {\n        return { type: \"CallExpression\", callee: callee, arguments: args };\n      }\n    )\n    tail:(\n        __ args:Arguments {\n          return { type: \"CallExpression\", arguments: args };\n        }\n      / __ \"[\" __ property:Expression __ \"]\" {\n          return {\n            type: \"MemberExpression\",\n            property: property,\n            computed: true\n          };\n        }\n      / __ \".\" __ property:IdentifierName {\n          return {\n            type: \"MemberExpression\",\n            property: property,\n            computed: false\n          };\n        }\n    )*\n    {\n      return tail.reduce(function(result, element) {\n        element[TYPES_TO_PROPERTY_NAMES[element.type]] = result;\n\n        return element;\n      }, head);\n    }\n\nArguments\n  = \"(\" __ args:(ArgumentList __)? \")\" {\n      return optionalList(extractOptional(args, 0));\n    }\n\nArgumentList\n  = head:AssignmentExpression tail:(__ \",\" __ AssignmentExpression)* {\n      return buildList(head, tail, 3);\n    }\n\nLeftHandSideExpression\n  = CallExpression\n  / NewExpression\n\nPostfixExpression\n  = argument:LeftHandSideExpression _ operator:PostfixOperator {\n      return {\n        type: \"UpdateExpression\",\n        operator: operator,\n        argument: argument,\n        prefix: false\n      };\n    }\n  / LeftHandSideExpression\n\nPostfixOperator\n  = \"++\"\n  / \"--\"\n\nUnaryExpression\n  = PostfixExpression\n  / operator:UnaryOperator __ argument:UnaryExpression {\n      var type = (operator === \"++\" || operator === \"--\")\n        ? \"UpdateExpression\"\n        : \"UnaryExpression\";\n\n      return {\n        type: type,\n        operator: operator,\n        argument: argument,\n        prefix: true\n      };\n    }\n\nUnaryOperator\n  = $DeleteToken\n  / $VoidToken\n  / $TypeofToken\n  / \"++\"\n  / \"--\"\n  / $(\"+\" !\"=\")\n  / $(\"-\" !\"=\")\n  / \"~\"\n  / \"!\"\n\nMultiplicativeExpression\n  = head:UnaryExpression\n    tail:(__ MultiplicativeOperator __ UnaryExpression)*\n    { return buildBinaryExpression(head, tail); }\n\nMultiplicativeOperator\n  = $(\"*\" !\"=\")\n  / $(\"/\" !\"=\")\n  / $(\"%\" !\"=\")\n\nAdditiveExpression\n  = head:MultiplicativeExpression\n    tail:(__ AdditiveOperator __ MultiplicativeExpression)*\n    { return buildBinaryExpression(head, tail); }\n\nAdditiveOperator\n  = $(\"+\" ![+=])\n  / $(\"-\" ![-=])\n\nShiftExpression\n  = head:AdditiveExpression\n    tail:(__ ShiftOperator __ AdditiveExpression)*\n    { return buildBinaryExpression(head, tail); }\n\nShiftOperator\n  = $(\"<<\"  !\"=\")\n  / $(\">>>\" !\"=\")\n  / $(\">>\"  !\"=\")\n\nRelationalExpression\n  = head:ShiftExpression\n    tail:(__ RelationalOperator __ ShiftExpression)*\n    { return buildBinaryExpression(head, tail); }\n\nRelationalOperator\n  = \"<=\"\n  / \">=\"\n  / $(\"<\" !\"<\")\n  / $(\">\" !\">\")\n  / $InstanceofToken\n  / $InToken\n\nRelationalExpressionNoIn\n  = head:ShiftExpression\n    tail:(__ RelationalOperatorNoIn __ ShiftExpression)*\n    { return buildBinaryExpression(head, tail); }\n\nRelationalOperatorNoIn\n  = \"<=\"\n  / \">=\"\n  / $(\"<\" !\"<\")\n  / $(\">\" !\">\")\n  / $InstanceofToken\n\nEqualityExpression\n  = head:RelationalExpression\n    tail:(__ EqualityOperator __ RelationalExpression)*\n    { return buildBinaryExpression(head, tail); }\n\nEqualityExpressionNoIn\n  = head:RelationalExpressionNoIn\n    tail:(__ EqualityOperator __ RelationalExpressionNoIn)*\n    { return buildBinaryExpression(head, tail); }\n\nEqualityOperator\n  = \"===\"\n  / \"!==\"\n  / \"==\"\n  / \"!=\"\n\nBitwiseANDExpression\n  = head:EqualityExpression\n    tail:(__ BitwiseANDOperator __ EqualityExpression)*\n    { return buildBinaryExpression(head, tail); }\n\nBitwiseANDExpressionNoIn\n  = head:EqualityExpressionNoIn\n    tail:(__ BitwiseANDOperator __ EqualityExpressionNoIn)*\n    { return buildBinaryExpression(head, tail); }\n\nBitwiseANDOperator\n  = $(\"&\" ![&=])\n\nBitwiseXORExpression\n  = head:BitwiseANDExpression\n    tail:(__ BitwiseXOROperator __ BitwiseANDExpression)*\n    { return buildBinaryExpression(head, tail); }\n\nBitwiseXORExpressionNoIn\n  = head:BitwiseANDExpressionNoIn\n    tail:(__ BitwiseXOROperator __ BitwiseANDExpressionNoIn)*\n    { return buildBinaryExpression(head, tail); }\n\nBitwiseXOROperator\n  = $(\"^\" !\"=\")\n\nBitwiseORExpression\n  = head:BitwiseXORExpression\n    tail:(__ BitwiseOROperator __ BitwiseXORExpression)*\n    { return buildBinaryExpression(head, tail); }\n\nBitwiseORExpressionNoIn\n  = head:BitwiseXORExpressionNoIn\n    tail:(__ BitwiseOROperator __ BitwiseXORExpressionNoIn)*\n    { return buildBinaryExpression(head, tail); }\n\nBitwiseOROperator\n  = $(\"|\" ![|=])\n\nLogicalANDExpression\n  = head:BitwiseORExpression\n    tail:(__ LogicalANDOperator __ BitwiseORExpression)*\n    { return buildLogicalExpression(head, tail); }\n\nLogicalANDExpressionNoIn\n  = head:BitwiseORExpressionNoIn\n    tail:(__ LogicalANDOperator __ BitwiseORExpressionNoIn)*\n    { return buildLogicalExpression(head, tail); }\n\nLogicalANDOperator\n  = \"&&\"\n\nLogicalORExpression\n  = head:LogicalANDExpression\n    tail:(__ LogicalOROperator __ LogicalANDExpression)*\n    { return buildLogicalExpression(head, tail); }\n\nLogicalORExpressionNoIn\n  = head:LogicalANDExpressionNoIn\n    tail:(__ LogicalOROperator __ LogicalANDExpressionNoIn)*\n    { return buildLogicalExpression(head, tail); }\n\nLogicalOROperator\n  = \"||\"\n\nConditionalExpression\n  = test:LogicalORExpression __\n    \"?\" __ consequent:AssignmentExpression __\n    \":\" __ alternate:AssignmentExpression\n    {\n      return {\n        type: \"ConditionalExpression\",\n        test: test,\n        consequent: consequent,\n        alternate: alternate\n      };\n    }\n  / LogicalORExpression\n\nConditionalExpressionNoIn\n  = test:LogicalORExpressionNoIn __\n    \"?\" __ consequent:AssignmentExpression __\n    \":\" __ alternate:AssignmentExpressionNoIn\n    {\n      return {\n        type: \"ConditionalExpression\",\n        test: test,\n        consequent: consequent,\n        alternate: alternate\n      };\n    }\n  / LogicalORExpressionNoIn\n\nAssignmentExpression\n  = left:LeftHandSideExpression __\n    \"=\" !\"=\" __\n    right:AssignmentExpression\n    {\n      return {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: left,\n        right: right\n      };\n    }\n  / left:LeftHandSideExpression __\n    operator:AssignmentOperator __\n    right:AssignmentExpression\n    {\n      return {\n        type: \"AssignmentExpression\",\n        operator: operator,\n        left: left,\n        right: right\n      };\n    }\n  / ConditionalExpression\n\nAssignmentExpressionNoIn\n  = left:LeftHandSideExpression __\n    \"=\" !\"=\" __\n    right:AssignmentExpressionNoIn\n    {\n      return {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: left,\n        right: right\n      };\n    }\n  / left:LeftHandSideExpression __\n    operator:AssignmentOperator __\n    right:AssignmentExpressionNoIn\n    {\n      return {\n        type: \"AssignmentExpression\",\n        operator: operator,\n        left: left,\n        right: right\n      };\n    }\n  / ConditionalExpressionNoIn\n\nAssignmentOperator\n  = \"*=\"\n  / \"/=\"\n  / \"%=\"\n  / \"+=\"\n  / \"-=\"\n  / \"<<=\"\n  / \">>=\"\n  / \">>>=\"\n  / \"&=\"\n  / \"^=\"\n  / \"|=\"\n\nExpression\n  = head:AssignmentExpression tail:(__ \",\" __ AssignmentExpression)* {\n      return tail.length > 0\n        ? { type: \"SequenceExpression\", expressions: buildList(head, tail, 3) }\n        : head;\n    }\n\nExpressionNoIn\n  = head:AssignmentExpressionNoIn tail:(__ \",\" __ AssignmentExpressionNoIn)* {\n      return tail.length > 0\n        ? { type: \"SequenceExpression\", expressions: buildList(head, tail, 3) }\n        : head;\n    }\n\n// ----- A.4 Statements -----\n\nStatement\n  = Block\n  / VariableStatement\n  / EmptyStatement\n  / ExpressionStatement\n  / IfStatement\n  / IterationStatement\n  / ContinueStatement\n  / BreakStatement\n  / ReturnStatement\n  / WithStatement\n  / LabelledStatement\n  / SwitchStatement\n  / ThrowStatement\n  / TryStatement\n  / DebuggerStatement\n\nBlock\n  = \"{\" __ body:(StatementList __)? \"}\" {\n      return {\n        type: \"BlockStatement\",\n        body: optionalList(extractOptional(body, 0))\n      };\n    }\n\nStatementList\n  = head:Statement tail:(__ Statement)* { return buildList(head, tail, 1); }\n\nVariableStatement\n  = VarToken __ declarations:VariableDeclarationList EOS {\n      return {\n        type: \"VariableDeclaration\",\n        declarations: declarations,\n        kind: \"var\"\n      };\n    }\n\nVariableDeclarationList\n  = head:VariableDeclaration tail:(__ \",\" __ VariableDeclaration)* {\n      return buildList(head, tail, 3);\n    }\n\nVariableDeclarationListNoIn\n  = head:VariableDeclarationNoIn tail:(__ \",\" __ VariableDeclarationNoIn)* {\n      return buildList(head, tail, 3);\n    }\n\nVariableDeclaration\n  = id:Identifier init:(__ Initialiser)? {\n      return {\n        type: \"VariableDeclarator\",\n        id: id,\n        init: extractOptional(init, 1)\n      };\n    }\n\nVariableDeclarationNoIn\n  = id:Identifier init:(__ InitialiserNoIn)? {\n      return {\n        type: \"VariableDeclarator\",\n        id: id,\n        init: extractOptional(init, 1)\n      };\n    }\n\nInitialiser\n  = \"=\" !\"=\" __ expression:AssignmentExpression { return expression; }\n\nInitialiserNoIn\n  = \"=\" !\"=\" __ expression:AssignmentExpressionNoIn { return expression; }\n\nEmptyStatement\n  = \";\" { return { type: \"EmptyStatement\" }; }\n\nExpressionStatement\n  = !(\"{\" / FunctionToken) expression:Expression EOS {\n      return {\n        type: \"ExpressionStatement\",\n        expression: expression\n      };\n    }\n\nIfStatement\n  = IfToken __ \"(\" __ test:Expression __ \")\" __\n    consequent:Statement __\n    ElseToken __\n    alternate:Statement\n    {\n      return {\n        type: \"IfStatement\",\n        test: test,\n        consequent: consequent,\n        alternate: alternate\n      };\n    }\n  / IfToken __ \"(\" __ test:Expression __ \")\" __\n    consequent:Statement {\n      return {\n        type: \"IfStatement\",\n        test: test,\n        consequent: consequent,\n        alternate: null\n      };\n    }\n\nIterationStatement\n  = DoToken __\n    body:Statement __\n    WhileToken __ \"(\" __ test:Expression __ \")\" EOS\n    { return { type: \"DoWhileStatement\", body: body, test: test }; }\n  / WhileToken __ \"(\" __ test:Expression __ \")\" __\n    body:Statement\n    { return { type: \"WhileStatement\", test: test, body: body }; }\n  / ForToken __\n    \"(\" __\n    init:(ExpressionNoIn __)? \";\" __\n    test:(Expression __)? \";\" __\n    update:(Expression __)?\n    \")\" __\n    body:Statement\n    {\n      return {\n        type: \"ForStatement\",\n        init: extractOptional(init, 0),\n        test: extractOptional(test, 0),\n        update: extractOptional(update, 0),\n        body: body\n      };\n    }\n  / ForToken __\n    \"(\" __\n    VarToken __ declarations:VariableDeclarationListNoIn __ \";\" __\n    test:(Expression __)? \";\" __\n    update:(Expression __)?\n    \")\" __\n    body:Statement\n    {\n      return {\n        type: \"ForStatement\",\n        init: {\n          type: \"VariableDeclaration\",\n          declarations: declarations,\n          kind: \"var\"\n        },\n        test: extractOptional(test, 0),\n        update: extractOptional(update, 0),\n        body: body\n      };\n    }\n  / ForToken __\n    \"(\" __\n    left:LeftHandSideExpression __\n    InToken __\n    right:Expression __\n    \")\" __\n    body:Statement\n    {\n      return {\n        type: \"ForInStatement\",\n        left: left,\n        right: right,\n        body: body\n      };\n    }\n  / ForToken __\n    \"(\" __\n    VarToken __ declarations:VariableDeclarationListNoIn __\n    InToken __\n    right:Expression __\n    \")\" __\n    body:Statement\n    {\n      return {\n        type: \"ForInStatement\",\n        left: {\n          type: \"VariableDeclaration\",\n          declarations: declarations,\n          kind: \"var\"\n        },\n        right: right,\n        body: body\n      };\n    }\n\nContinueStatement\n  = ContinueToken EOS {\n      return { type: \"ContinueStatement\", label: null };\n    }\n  / ContinueToken _ label:Identifier EOS {\n      return { type: \"ContinueStatement\", label: label };\n    }\n\nBreakStatement\n  = BreakToken EOS {\n      return { type: \"BreakStatement\", label: null };\n    }\n  / BreakToken _ label:Identifier EOS {\n      return { type: \"BreakStatement\", label: label };\n    }\n\nReturnStatement\n  = ReturnToken EOS {\n      return { type: \"ReturnStatement\", argument: null };\n    }\n  / ReturnToken _ argument:Expression EOS {\n      return { type: \"ReturnStatement\", argument: argument };\n    }\n\nWithStatement\n  = WithToken __ \"(\" __ object:Expression __ \")\" __\n    body:Statement\n    { return { type: \"WithStatement\", object: object, body: body }; }\n\nSwitchStatement\n  = SwitchToken __ \"(\" __ discriminant:Expression __ \")\" __\n    cases:CaseBlock\n    {\n      return {\n        type: \"SwitchStatement\",\n        discriminant: discriminant,\n        cases: cases\n      };\n    }\n\nCaseBlock\n  = \"{\" __ clauses:(CaseClauses __)? \"}\" {\n      return optionalList(extractOptional(clauses, 0));\n    }\n  / \"{\" __\n    before:(CaseClauses __)?\n    default_:DefaultClause __\n    after:(CaseClauses __)? \"}\"\n    {\n      return optionalList(extractOptional(before, 0))\n        .concat(default_)\n        .concat(optionalList(extractOptional(after, 0)));\n    }\n\nCaseClauses\n  = head:CaseClause tail:(__ CaseClause)* { return buildList(head, tail, 1); }\n\nCaseClause\n  = CaseToken __ test:Expression __ \":\" consequent:(__ StatementList)? {\n      return {\n        type: \"SwitchCase\",\n        test: test,\n        consequent: optionalList(extractOptional(consequent, 1))\n      };\n    }\n\nDefaultClause\n  = DefaultToken __ \":\" consequent:(__ StatementList)? {\n      return {\n        type: \"SwitchCase\",\n        test: null,\n        consequent: optionalList(extractOptional(consequent, 1))\n      };\n    }\n\nLabelledStatement\n  = label:Identifier __ \":\" __ body:Statement {\n      return { type: \"LabeledStatement\", label: label, body: body };\n    }\n\nThrowStatement\n  = ThrowToken _ argument:Expression EOS {\n      return { type: \"ThrowStatement\", argument: argument };\n    }\n\nTryStatement\n  = TryToken __ block:Block __ handler:Catch __ finalizer:Finally {\n      return {\n        type: \"TryStatement\",\n        block: block,\n        handler: handler,\n        finalizer: finalizer\n      };\n    }\n  / TryToken __ block:Block __ handler:Catch {\n      return {\n        type: \"TryStatement\",\n        block: block,\n        handler: handler,\n        finalizer: null\n      };\n    }\n  / TryToken __ block:Block __ finalizer:Finally {\n      return {\n        type: \"TryStatement\",\n        block: block,\n        handler: null,\n        finalizer: finalizer\n      };\n    }\n\nCatch\n  = CatchToken __ \"(\" __ param:Identifier __ \")\" __ body:Block {\n      return {\n        type: \"CatchClause\",\n        param: param,\n        body: body\n      };\n    }\n\nFinally\n  = FinallyToken __ block:Block { return block; }\n\nDebuggerStatement\n  = DebuggerToken EOS { return { type: \"DebuggerStatement\" }; }\n\n// ----- A.5 Functions and Programs -----\n\nFunctionDeclaration\n  = FunctionToken __ id:Identifier __\n    \"(\" __ params:(FormalParameterList __)? \")\" __\n    \"{\" __ body:FunctionBody __ \"}\"\n    {\n      return {\n        type: \"FunctionDeclaration\",\n        id: id,\n        params: optionalList(extractOptional(params, 0)),\n        body: body\n      };\n    }\n\nFunctionExpression\n  = FunctionToken __ id:(Identifier __)?\n    \"(\" __ params:(FormalParameterList __)? \")\" __\n    \"{\" __ body:FunctionBody __ \"}\"\n    {\n      return {\n        type: \"FunctionExpression\",\n        id: extractOptional(id, 0),\n        params: optionalList(extractOptional(params, 0)),\n        body: body\n      };\n    }\n\nFormalParameterList\n  = head:Identifier tail:(__ \",\" __ Identifier)* {\n      return buildList(head, tail, 3);\n    }\n\nFunctionBody\n  = body:SourceElements? {\n      return {\n        type: \"BlockStatement\",\n        body: optionalList(body)\n      };\n    }\n\nProgram\n  = body:SourceElements? {\n      return {\n        type: \"Program\",\n        body: optionalList(body)\n      };\n    }\n\nSourceElements\n  = head:SourceElement tail:(__ SourceElement)* {\n      return buildList(head, tail, 1);\n    }\n\nSourceElement\n  = Statement\n  / FunctionDeclaration\n\n// ----- A.6 Universal Resource Identifier Character Classes -----\n\n// Irrelevant.\n\n// ----- A.7 Regular Expressions -----\n\n// Irrelevant.\n\n// ----- A.8 JSON -----\n\n// Irrelevant.\n";
