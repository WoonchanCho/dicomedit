{"version":3,"sources":["webpack://DicomEdit/./Parser.js","webpack://DicomEdit/webpack/runtime/getFullHash"],"names":["DEFAULT_GRAMMAR","fs","log","debug","APP_NAME","PARSER_TYPE","Parser","constructor","rawParser","parse","script","defaultParser","generateParser","generateParserFromFile","filename","undefined","options","trace","grammar","peg","ast","produceAbstractSyntaxTree","final","produceRuleGroup","parserOptions","tracer","Tracer","showFullPath","err","LexicalError","message","validateAst","version","body","ruleGroup","RuleGroup","forEach","element","rule","Rule","addRule","RuleError","severiry","RULE_RESULT_STATUSES","ParseError","type","DEFAULT_SCRIPT_VERSION","SUPPORTED_SCRIPT_VERSIONS","item","String","length"],"mappings":"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","file":"dicomedit.3d67a854ff28a08e6fd4.hot-update.js","sourcesContent":["import peg from 'pegjs';\nimport Tracer from 'pegjs-backtrace';\nimport debug from 'debug';\nimport fs from 'fs';\n\nimport {\n  APP_NAME,\n  DEFAULT_SCRIPT_VERSION,\n  SUPPORTED_SCRIPT_VERSIONS,\n  RULE_RESULT_STATUSES,\n} from './Common/Constant';\nimport { LexicalError, ParseError, RuleError } from './Error';\nimport { Rule, RuleGroup } from './index';\n// import DEFAULT_GRAMMAR from '!!raw-loader!./Peg/Grammar.peg';\nconst DEFAULT_GRAMMAR = fs.readFileSync('./Peg/Grammar.peg');\n\nconst log = debug(`${APP_NAME}:Parser`);\nconst PARSER_TYPE = 'DicomEdit';\n\nexport default class Parser {\n  constructor(rawParser) {\n    this.rawParser = rawParser;\n  }\n\n  static parse(script) {\n    const defaultParser = Parser.generateParser();\n    return defaultParser.parse(script);\n  }\n\n  static generateParserFromFile(\n    filename = undefined,\n    options = { trace: false }\n  ) {\n    const grammar = filename\n      ? fs.readFileSync(filename, 'utf8')\n      : DEFAULT_GRAMMAR;\n\n    return Parser.generateParser(grammar, { trace: options.trace });\n  }\n\n  static generateParser(grammar = undefined, options = { trace: false }) {\n    return new Parser(\n      peg.generate(grammar ? grammar : DEFAULT_GRAMMAR, {\n        trace: options.trace,\n      })\n    );\n  }\n\n  parse(script, options = {}) {\n    const ast = this.produceAbstractSyntaxTree(script, options);\n    const final = this.produceRuleGroup(ast);\n\n    return final;\n  }\n\n  produceAbstractSyntaxTree(script, options = {}) {\n    log('Producing Abstract Syntax Tree');\n    const { trace } = options;\n    let parserOptions = {};\n    let tracer;\n    if (trace === true) {\n      tracer = new Tracer(script, { showFullPath: true });\n      parserOptions.tracer = tracer;\n    }\n    try {\n      return this.rawParser.parse(script, parserOptions);\n    } catch (err) {\n      throw new LexicalError(err.message, err, tracer);\n    }\n  }\n\n  produceRuleGroup(ast) {\n    log('Producing Rule Group');\n    this.validateAst(ast);\n    const { version, body } = ast;\n    const ruleGroup = new RuleGroup(version);\n\n    body.forEach((element) => {\n      try {\n        const rule = Rule.fromLexical(element);\n        if (rule) {\n          ruleGroup.addRule(rule);\n        }\n      } catch (err) {\n        if (\n          !(err instanceof RuleError) ||\n          err.severiry === RULE_RESULT_STATUSES.FATAL\n        ) {\n          throw err;\n        }\n      }\n    });\n    return ruleGroup;\n  }\n\n  validateAst(ast) {\n    if (!ast) {\n      throw new ParseError(`Abstract syntax tree is empty`, ast);\n    }\n    const { type, version } = ast;\n    if (type !== PARSER_TYPE) {\n      throw new ParseError(\n        `The AST type should be ${PARSER_TYPE}, but the type for this AST is ${type}`\n      );\n    }\n    if (!version) {\n      ast.version = DEFAULT_SCRIPT_VERSION;\n    }\n    if (\n      !SUPPORTED_SCRIPT_VERSIONS.filter((item) => item === String(version))\n        .length\n    ) {\n      throw new Parser(`The provided version (${version}) is not supported`);\n    }\n  }\n}\n","__webpack_require__.h = () => \"54de24e09da37cae3da3\""],"sourceRoot":""}